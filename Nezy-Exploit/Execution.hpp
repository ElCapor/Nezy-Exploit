#include <iostream>
#include <Windows.h>
#include <string>
#include <thread>
#include <vector>
#include <mutex>

#include "Api.hpp"


class bytecode_encoder_t : public Luau::BytecodeEncoder
{
	std::uint8_t encodeOp(const std::uint8_t opcode)
	{
		return opcode * 227;
	}
};


std::string gen_random(const int len) {
    static const char alphanum[] =
        "0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
    std::string tmp_s;
    tmp_s.reserve(len);
    for (int i = 0; i < len; ++i) {
        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];
    }
    return tmp_s;
}


namespace Lua
{
	void push_warn(const char* source)
	{
		Addresses::r_lua_print(2, source);
	}


	void r_securitylevel(uintptr_t rs, int8_t identity)
	{
		*reinterpret_cast<int8_t*>(*reinterpret_cast<uintptr_t*>(rs + 72) + 24) = identity;
	}
}


namespace Execution
{
	void execute(uintptr_t rs, std::string source)
	{
		bytecode_encoder_t enc;

		std::string bytecode = Luau::compile(source, {}, {}, &enc);
		if (bytecode.at(0) == 0)
		{
			const char* error = bytecode.c_str() + 1;
			Lua::push_warn(error);
		}
		else
		{
			Addresses::r_luau_load(rs, gen_random(18).c_str(), bytecode.c_str(), bytecode.size(), NULL);
			Addresses::r_lua_taskdefer(rs);
			Lua::r_decrement_top(rs);
		}
	}


	void pipe()
	{
		std::string ScriptBuffer;
		char Buffer[999999];
		DWORD ReadWords;
		void* PipeHandle = CreateNamedPipe(TEXT("\\\\.\\pipe\\NezyPipe"), PIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, PIPE_WAIT, 1, 999999, 999999, NMPWAIT_USE_DEFAULT_WAIT, 0);
		while (true)
		{
			if (ConnectNamedPipe(PipeHandle, 0))
			{
				while (ReadFile(PipeHandle, Buffer, sizeof(Buffer) - 1, &ReadWords, 0))
				{
					Buffer[ReadWords] = '\0';
					ScriptBuffer.append(Buffer);
				}

				Execution::execute(roblox_state, ScriptBuffer);
				ScriptBuffer.clear();
			}
			DisconnectNamedPipe(PipeHandle);
		}
	}
}
