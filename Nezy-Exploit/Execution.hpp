#include <iostream>
#include <Windows.h>
#include <string>
#include <thread>
#include <vector>
#include <mutex>

#include "LuaState.hpp"
#include "Compiler/include/BytecodeBuilder.h"
#include "Compiler/include/Compiler.h"


class bytecode_encoder_t : public Luau::BytecodeEncoder
{
	std::uint8_t encodeOp(const std::uint8_t opcode)
	{
		return opcode * 227;
	}
};


namespace Lua
{
	void push_warn(const char* source)
	{
		Addresses::r_lua_print(2, source);
	}


	void r_securitylevel(uintptr_t rs, int8_t identity)
	{
		*reinterpret_cast<int8_t*>(*reinterpret_cast<uintptr_t*>(rs + 72) + 24) = identity;
	}
}


namespace Execution
{
	void execute(uintptr_t rs, std::string source)
	{
		bytecode_encoder_t enc;

		uintptr_t new_state = Addresses::r_lua_newthread(rs);
		std::string bytecode = Luau::compile(source, {}, {}, &enc);
		if (bytecode.at(0) == 0)
		{
			const char* error = bytecode.c_str() + 1;
			const char* pushment = ("[string 'nezy.xyz']", error);
			Lua::push_warn(pushment);
		}
		else
		{
			Addresses::r_luau_load(new_state, "@nezy.xyz", bytecode.c_str(), bytecode.size(), NULL);
			Addresses::r_lua_taskdefer(new_state);
		}
	}


	void pipe()
	{
		std::string ScriptBuffer;
		char Buffer[999999];
		DWORD ReadWords;
		void* PipeHandle = CreateNamedPipe(TEXT("\\\\.\\pipe\\NezyPipe"), PIPE_ACCESS_DUPLEX | PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, PIPE_WAIT, 1, 999999, 999999, NMPWAIT_USE_DEFAULT_WAIT, 0);
		while (true)
		{
			if (ConnectNamedPipe(PipeHandle, 0))
			{
				while (ReadFile(PipeHandle, Buffer, sizeof(Buffer) - 1, &ReadWords, 0))
				{
					Buffer[ReadWords] = '\0';
					ScriptBuffer.append(Buffer);
				}

				if (ScriptBuffer != "")
				{
					Execution::execute(roblox_state, ScriptBuffer);
				}
				ScriptBuffer.clear();
			}
			DisconnectNamedPipe(PipeHandle);
		}
	}
}